package Hitch.persistance;

import java.io.*;
import java.sql.*;
import java.util.Scanner;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;

/**
 *  Should be extending the Rides class, that hasnt been written
 *  If a ride is deleted/inserted you must both call fetchRides() and createRideArray()
 *
 * The class has the attribute int[][] rideArray that always has all the rides in it since
 * its last update. It does not get updated automatically
 * I could do it
 * But I didnt
 * Its the simple matter of calling fethRides() and createRideArray() in the back of deleteRide() and
 * insertRide()
 * I feel like I have explained this enough
 *
 * A unique ID is created for each ride
 * The database is designed in such a way that a phone number can occur more than once, i.e a phonenumber
 * isnt unique in the database, this should probably be fixed
 *
 * This is the database schema
 *
 * create table rides(
 *	id INTEGER primary key autoincrement,
 *	pickup int,
 *	destination int,
 *	phone int
 *	);
 *
 * Just add 'unique' right behind 'phone int' so that it reads 'phone int unique'
 *
 * Goodbye
 */
public class SQLHelper2{
  private Connection connection;

  private int[] rideData            = new int[4];
//  private LinkedList<int[]>  rides  = new LinkedList(); //need a linked list becouse the result of a sqlite query doesnt have length with it
  private int[][] rideArray;


  private final String[] columnNames        = new String[]{"id", "pickup", "destination", "phone"};
  private final String   selection          = "select id, pickup, destination, phone from rides;";
  private final String   insertion          = "insert into rides(pickup, destination, phone) values(?,?,?);";
  private final String   remove             = "delete from rides where id is (?);";


  /**
   * [createConnection description]
   * Use: createConnection()
   * After: static variable connection is now connected to database data.db
   * Used by insertRide() and fetchRides()
   */
  public void createConnection(){
    connection = null;
    try {
      Class.forName("org.sqlite.JDBC");
      connection = DriverManager.getConnection("jdbc:sqlite:data.db");
    } catch ( Exception e ) {
      System.err.println( e.getClass().getName() + ": " + e.getMessage() );
      System.exit(0);
    }
    System.out.println("Opened database successfully");
  }

  /**
   * [deleteRide description]
   * Use: deleteRide(rideID)
   * After: ride with rideID id has been removed from the database
   * @param rideID [ID of ride request to be deleted]
   */
  public void deleteRide(int rideID) {
    createConnection();
    try{
      connection.setAutoCommit(false);
      PreparedStatement statement = connection.prepareStatement(remove);
      statement.setInt(1,rideID);

      statement.executeUpdate();
      connection.commit();
      connection.close();

    } catch (SQLException ex) {
      System.out.println(ex.getMessage());
    } catch (Exception e){
      System.out.println("insertions Error");
    }
    updateRides();
  }

  /**
   * [insertRide description]
   * Use: insertRide(values)
   * After: A new ride request has been added to the database
   * @param values : array of 3 integers, pickup location, dropoff location, and phone number
   * Arguements could be divided into these three parts but this is more neat
   * But secretly its retarded to have an array for 3 values, made another one
   */
  public void insertRide(int[] values){
    createConnection();
    try{
      connection.setAutoCommit(false);
      PreparedStatement statement = connection.prepareStatement(insertion);
      for (int i = 1; i <= values.length; i++ ) {
        statement.setInt(i,values[i-1]);
      }
      statement.executeUpdate();
      statement.close();
      connection.commit();
      connection.close();

    } catch (SQLException ex) {
      System.out.println(ex.getMessage());
    } catch (Exception e){
      System.out.println("insertions Error");
    }
  }

  /**
   * [insertRide description]
   * Use: insertRide(pickup, dropoff,phone)
   * After: A new ride request has been added to the database
   * @param pickup  [pickup location pls]
   * @param dropoff [jesus]
   * @param phone   [this explains itself these comment sections are autogenerated]
   */
  public void insertRide(int pickup, int dropoff, int phone){
    createConnection();
    try{
      connection.setAutoCommit(false);
      PreparedStatement statement = connection.prepareStatement(insertion);

      statement.setInt(1,pickup);
      statement.setInt(2,dropoff);
      statement.setInt(3,phone);

      statement.executeUpdate();
      statement.close();
      connection.commit();
      connection.close();

    } catch (SQLException ex) {
      System.out.println(ex.getMessage());
    } catch (Exception e){
      System.out.println("insertions Error");
    }
    updateRides();
  }

  /**
   * [fetchRides description]
   * Use: fetchRides()
   * After: The array rideArray has rows populated by individual requested rides
   */
  public void updateRides(){
    createConnection();
    LinkedList<int[]>  rides  = new LinkedList();

    try{
      connection.setAutoCommit(false);
      PreparedStatement statement = connection.prepareStatement(selection);
      ResultSet resultSet = statement.executeQuery();


      while(resultSet.next()) {
        rideData = new int[4];
        rideData[0] = resultSet.getInt(columnNames[0]);
        rideData[1] = resultSet.getInt(columnNames[1]);
        rideData[2] = resultSet.getInt(columnNames[2]);
        rideData[3] = resultSet.getInt(columnNames[3]);
        rides.add(rideData);
      }

      resultSet.close();
      statement.close();
      connection.close();

    } catch (SQLException ex) {
      System.out.println(ex.getMessage());
    } catch (Exception e){System.out.println("fail");}

    createRideArray(rides);
  }

  /**
   * [createRideArray description]
   * Use: createRideArray()
   * After: takes the LinkedList object called rides, and empties it into the int[][] matrix called rideArray
   */
  public void createRideArray(LinkedList<int[]> rides){
    int count = rides.size();
    rideArray = new int[count][4];

    for (int i = 0; i < count;i++ ) {
      rideArray[i] = rides.remove();
    }
  }


  /**
   * [printMatrix description]
   * Use: printMatrix(matrix)
   * @param matrix [int[][] that needs to be printed]
   */
  public void printMatrix(int[][] matrix) {
    for (int i = 0; i < matrix.length; i++) {
      for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
      }
      System.out.println("");
    }
  }

  /**
   * [printArray description]
   * Use: printArray(array)
   * @param array [int[] array to be printed]
   */
  public void printArray(int[] array) {
    for (int i = 0; i < array.length; i++) {
      System.out.print(array[i] + " ");
    }
    System.out.println("");
  }

  public int[][] getRideArray() {
    return this.rideArray;
  }
}